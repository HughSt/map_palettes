layer = layer_index)
# Identify where missing values are
data_index <- which(!is.na(all_data$data))
missing_index <- which(is.na(all_data$data))
# Identify all pixels adjacent to missing values
# work in progress...
# boundary_pixels <- data.frame(layer=NULL, cell=NULL)
# for(i in 1:dim(x)[3]){
#   missing_pixels_adjacent <- adjacent(x[[i]], which(is.na(x[[i]][])))[,2]
#
#   if(length(missing_pixels_adjacent)>0){
#     boundary_pixels_index <- missing_pixels_adjacent[which(!is.na(x[[i]][missing_pixels_adjacent]))]
#
#     if(length(boundary_pixels_index)>(data_points/12)){
#       boundary_pixels_index <- boundary_pixels_index[round(seq(1, length(boundary_pixels_index),
#                                                                length.out=round(data_points/12)))]
#     }
#
#     # TODO (potentially) remove any that have a missing value in an adjacent
#     # cell on the elevation raster (i.e. along the coast)
#     boundary_pixels <- rbind(boundary_pixels, cbind(i,boundary_pixels_index))
#   }
#
# }
# temporally_adjacent_pixels <- data.frame(layer=NULL, cell=NULL)
# for(j in 1:dim(x)[3]){
#
#   missing_pixels <- which(is.na(x[[j]][]))
# }
# Include nearest value in time for each missing pixel
# Take a sequential sample of data
if(length(data_index) >= data_points){
sample_index <- data_index
}else{
sample_index <- data_index[round(seq(1, length(data_index), length.out=data_points))]
}
model_data <- all_data[sample_index,]
model_data$cell <- raster::cellFromXY(x, model_data[,c("x","y")])
pred_data <- all_data[missing_index,]
pred_data$cell <- raster::cellFromXY(x, pred_data[,c("x","y")])
# If there are multiple rasterLayers, use the approxNA function to get linear interpolations
# for missing values which will act as a covariate
if(n_layers > 1){
model_data$interpolation <- get_approxNA(x, model_data)
pred_data$interpolation <- get_approxNA(x, pred_data)
}else{
model_data$interpolation <- 0
pred_data$interpolation <- 0
}
# Remove any cells which are na in Elevation
# i.e. these lie outside the country
model_data <- model_data[complete.cases(model_data),]
pred_data <- pred_data[-which(pred_data$cell %in% which(is.na(Elev[]))),]
# Build model
rf_mod <- randomForest(data ~ interpolation + elev + x + y + layer,
data = model_data)
# Loop to inpute missing values
predictions <- predict(rf_mod, newdata = pred_data)
if(n_layers == 1){
x[pred_data$cell] <- as.vector(predictions)
}else{
for(i in 1:dim(x)[3]){
x[[i]][pred_data$cell[pred_data$layer == i]] <- as.vector(predictions[pred_data$layer == i])
}
}
return(x)
}
LST<-LST_gold_standard
plot(elevation)
grid_sizes <- 0.15
for (k in 1:length(grid_sizes)){
validation_grid <- expand.grid(x = seq(min(coordinates(LST)[,1]), max(coordinates(LST)[,1])+grid_sizes[1],
grid_sizes[k]),
y = seq(min(coordinates(LST)[,2]), max(coordinates(LST)[,2])+grid_sizes[1],
grid_sizes[k]))
}
# generate voronoi polygons
dd <- deldir(validation_grid$x, validation_grid$y)
tiles <- tile.list(dd)
polys <- vector(mode='list', length=length(tiles ))
for (i in seq(along=polys)) {
pcrds <- cbind(tiles [[i]]$x, tiles [[i]]$y)
pcrds <- rbind(pcrds, pcrds[1,])
polys[[i]] <- Polygons(list(Polygon(pcrds)), ID=as.character(i))
}
SP <- SpatialPolygons(polys)
# Randomly choose some squares to remove data from
nRemove <- 20
toRemove <- round(seq(1,length(SP),length.out = nRemove))
SPtoRemove <- SP[toRemove,]
# Ramdomly remove some data points
rasterCoords <- SpatialPoints(coordinates(LST[[1]]))
pixelsInSP <- over(rasterCoords, SPtoRemove)
RandSpace <- c(which(pixelsInSP<=nRemove/2),
which(pixelsInSP>nRemove/2))
RandTime <- c(rep(1,length(RandSpace)/2),rep(2,length(RandSpace)/2))
# RandSpace <- sample(which(!is.na(elevation[])),10000)
# RandTime <- sample(5:6,1000,replace=T)
# Store validation data
ValidationData<-NULL
for(i in 1:length(RandSpace)){
ValidationData <- c(ValidationData, LST[[RandTime[i]]][RandSpace[i]])
LST[[RandTime[i]]][RandSpace[i]] <- NA # remove
}
LST_gapfilled <- gapfill(LST, elevation, data_points = 40000)
gapfill <- function(x, data_points = 20000, Elev){
if(res(Elev)[1] != res(x)[1]){
stop("Resolutions of raster stack and elevation need to be the same!")
}
browser()
# sample non-missing points from each layer
n_layers <- dim(x)[3]
# Create layer index
layer_index <- sort(rep(1:n_layers,length(x)/n_layers))
# Create data frame of all data
all_data <- data.frame(x = rep(coordinates(x)[,1], n_layers),
y = rep(coordinates(x)[,2], n_layers),
data = as.vector(x[]),
elev = Elev[],
layer = layer_index)
# Identify where missing values are
data_index <- which(!is.na(all_data$data))
missing_index <- which(is.na(all_data$data))
# Identify all pixels adjacent to missing values
# work in progress...
# boundary_pixels <- data.frame(layer=NULL, cell=NULL)
# for(i in 1:dim(x)[3]){
#   missing_pixels_adjacent <- adjacent(x[[i]], which(is.na(x[[i]][])))[,2]
#
#   if(length(missing_pixels_adjacent)>0){
#     boundary_pixels_index <- missing_pixels_adjacent[which(!is.na(x[[i]][missing_pixels_adjacent]))]
#
#     if(length(boundary_pixels_index)>(data_points/12)){
#       boundary_pixels_index <- boundary_pixels_index[round(seq(1, length(boundary_pixels_index),
#                                                                length.out=round(data_points/12)))]
#     }
#
#     # TODO (potentially) remove any that have a missing value in an adjacent
#     # cell on the elevation raster (i.e. along the coast)
#     boundary_pixels <- rbind(boundary_pixels, cbind(i,boundary_pixels_index))
#   }
#
# }
# temporally_adjacent_pixels <- data.frame(layer=NULL, cell=NULL)
# for(j in 1:dim(x)[3]){
#
#   missing_pixels <- which(is.na(x[[j]][]))
# }
# Include nearest value in time for each missing pixel
# Take a sequential sample of data
if(length(data_index) >= data_points){
sample_index <- data_index
}else{
sample_index <- data_index[round(seq(1, length(data_index), length.out=data_points))]
}
model_data <- all_data[sample_index,]
model_data$cell <- raster::cellFromXY(x, model_data[,c("x","y")])
pred_data <- all_data[missing_index,]
pred_data$cell <- raster::cellFromXY(x, pred_data[,c("x","y")])
# If there are multiple rasterLayers, use the approxNA function to get linear interpolations
# for missing values which will act as a covariate
if(n_layers > 1){
model_data$interpolation <- get_approxNA(x, model_data)
pred_data$interpolation <- get_approxNA(x, pred_data)
}else{
model_data$interpolation <- 0
pred_data$interpolation <- 0
}
# Remove any cells which are na in Elevation
# i.e. these lie outside the country
model_data <- model_data[complete.cases(model_data),]
pred_data <- pred_data[-which(pred_data$cell %in% which(is.na(Elev[]))),]
# Build model
rf_mod <- randomForest(data ~ interpolation + elev + x + y + layer,
data = model_data)
# Loop to inpute missing values
predictions <- predict(rf_mod, newdata = pred_data)
if(n_layers == 1){
x[pred_data$cell] <- as.vector(predictions)
}else{
for(i in 1:dim(x)[3]){
x[[i]][pred_data$cell[pred_data$layer == i]] <- as.vector(predictions[pred_data$layer == i])
}
}
return(x)
}
LST_gapfilled <- gapfill(LST, elevation, data_points = 40000)
# sample non-missing points from each layer
n_layers <- dim(x)[3]
# Create layer index
layer_index <- sort(rep(1:n_layers,length(x)/n_layers))
# Create data frame of all data
all_data <- data.frame(x = rep(coordinates(x)[,1], n_layers),
y = rep(coordinates(x)[,2], n_layers),
data = as.vector(x[]),
elev = Elev[],
layer = layer_index)
# Identify where missing values are
data_index <- which(!is.na(all_data$data))
missing_index <- which(is.na(all_data$data))
length(data_index)
sample_index <- data_index[round(seq(1, length(data_index), length.out=data_points))]
model_data <- all_data[sample_index,]
model_data$cell <- raster::cellFromXY(x, model_data[,c("x","y")])
pred_data <- all_data[missing_index,]
pred_data$cell <- raster::cellFromXY(x, pred_data[,c("x","y")])
n_layers
model_data$interpolation <- get_approxNA(x, model_data)
pred_data$interpolation <- get_approxNA(x, pred_data)
# Remove any cells which are na in Elevation
# i.e. these lie outside the country
model_data <- model_data[complete.cases(model_data),]
pred_data <- pred_data[-which(pred_data$cell %in% which(is.na(Elev[]))),]
# Build model
rf_mod <- randomForest(data ~ interpolation + elev + x + y + layer,
data = model_data)
predictions <- predict(rf_mod, newdata = pred_data)
n_layers
for(i in 1:dim(x)[3]){
x[[i]][pred_data$cell[pred_data$layer == i]] <- as.vector(predictions[pred_data$layer == i])
}
gapfill <- function(x, data_points = 20000, Elev){
if(res(Elev)[1] != res(x)[1]){
stop("Resolutions of raster stack and elevation need to be the same!")
}
# sample non-missing points from each layer
n_layers <- dim(x)[3]
# Create layer index
layer_index <- sort(rep(1:n_layers,length(x)/n_layers))
# Create data frame of all data
all_data <- data.frame(x = rep(coordinates(x)[,1], n_layers),
y = rep(coordinates(x)[,2], n_layers),
data = as.vector(x[]),
elev = Elev[],
layer = layer_index)
# Identify where missing values are
data_index <- which(!is.na(all_data$data))
missing_index <- which(is.na(all_data$data))
# Identify all pixels adjacent to missing values
# work in progress...
# boundary_pixels <- data.frame(layer=NULL, cell=NULL)
# for(i in 1:dim(x)[3]){
#   missing_pixels_adjacent <- adjacent(x[[i]], which(is.na(x[[i]][])))[,2]
#
#   if(length(missing_pixels_adjacent)>0){
#     boundary_pixels_index <- missing_pixels_adjacent[which(!is.na(x[[i]][missing_pixels_adjacent]))]
#
#     if(length(boundary_pixels_index)>(data_points/12)){
#       boundary_pixels_index <- boundary_pixels_index[round(seq(1, length(boundary_pixels_index),
#                                                                length.out=round(data_points/12)))]
#     }
#
#     # TODO (potentially) remove any that have a missing value in an adjacent
#     # cell on the elevation raster (i.e. along the coast)
#     boundary_pixels <- rbind(boundary_pixels, cbind(i,boundary_pixels_index))
#   }
#
# }
# temporally_adjacent_pixels <- data.frame(layer=NULL, cell=NULL)
# for(j in 1:dim(x)[3]){
#
#   missing_pixels <- which(is.na(x[[j]][]))
# }
# Include nearest value in time for each missing pixel
# Take a sequential sample of data
if(length(data_index) >= data_points){
sample_index <- data_index
}else{
sample_index <- data_index[round(seq(1, length(data_index), length.out=data_points))]
}
model_data <- all_data[sample_index,]
model_data$cell <- raster::cellFromXY(x, model_data[,c("x","y")])
pred_data <- all_data[missing_index,]
pred_data$cell <- raster::cellFromXY(x, pred_data[,c("x","y")])
# If there are multiple rasterLayers, use the approxNA function to get linear interpolations
# for missing values which will act as a covariate
if(n_layers > 1){
model_data$interpolation <- get_approxNA(x, model_data)
pred_data$interpolation <- get_approxNA(x, pred_data)
}else{
model_data$interpolation <- 0
pred_data$interpolation <- 0
}
# Remove any cells which are na in Elevation
# i.e. these lie outside the country
model_data <- model_data[complete.cases(model_data),]
pred_data <- pred_data[-which(pred_data$cell %in% which(is.na(Elev[]))),]
# Build model
rf_mod <- randomForest(data ~ interpolation + elev + x + y + layer,
data = model_data)
# Loop to inpute missing values
predictions <- predict(rf_mod, newdata = pred_data)
if(n_layers == 1){
x[pred_data$cell] <- as.vector(predictions)
}else{
for(i in 1:dim(x)[3]){
x[[i]][pred_data$cell[pred_data$layer == i]] <- as.vector(predictions[pred_data$layer == i])
}
}
return(x)
}
LST_gapfilled <- gapfill(LST, elevation, data_points = 40000)
gapfill <- function(x, data_points = 20000, Elev){
if(res(Elev)[1] != res(x)[1]){
stop("Resolutions of raster stack and elevation need to be the same!")
}
# sample non-missing points from each layer
n_layers <- dim(x)[3]
# Create layer index
layer_index <- sort(rep(1:n_layers,length(x)/n_layers))
# Create data frame of all data
all_data <- data.frame(x = rep(coordinates(x)[,1], n_layers),
y = rep(coordinates(x)[,2], n_layers),
data = as.vector(x[]),
elev = Elev[],
layer = layer_index)
# Identify where missing values are
data_index <- which(!is.na(all_data$data))
missing_index <- which(is.na(all_data$data))
# Identify all pixels adjacent to missing values
# work in progress...
# boundary_pixels <- data.frame(layer=NULL, cell=NULL)
# for(i in 1:dim(x)[3]){
#   missing_pixels_adjacent <- adjacent(x[[i]], which(is.na(x[[i]][])))[,2]
#
#   if(length(missing_pixels_adjacent)>0){
#     boundary_pixels_index <- missing_pixels_adjacent[which(!is.na(x[[i]][missing_pixels_adjacent]))]
#
#     if(length(boundary_pixels_index)>(data_points/12)){
#       boundary_pixels_index <- boundary_pixels_index[round(seq(1, length(boundary_pixels_index),
#                                                                length.out=round(data_points/12)))]
#     }
#
#     # TODO (potentially) remove any that have a missing value in an adjacent
#     # cell on the elevation raster (i.e. along the coast)
#     boundary_pixels <- rbind(boundary_pixels, cbind(i,boundary_pixels_index))
#   }
#
# }
# temporally_adjacent_pixels <- data.frame(layer=NULL, cell=NULL)
# for(j in 1:dim(x)[3]){
#
#   missing_pixels <- which(is.na(x[[j]][]))
# }
# Include nearest value in time for each missing pixel
# Take a sequential sample of data
if(length(data_index) >= data_points){
sample_index <- data_index
}else{
sample_index <- data_index[round(seq(1, length(data_index), length.out=data_points))]
}
model_data <- all_data[sample_index,]
model_data$cell <- raster::cellFromXY(x, model_data[,c("x","y")])
pred_data <- all_data[missing_index,]
pred_data$cell <- raster::cellFromXY(x, pred_data[,c("x","y")])
# If there are multiple rasterLayers, use the approxNA function to get linear interpolations
# for missing values which will act as a covariate
if(n_layers > 1){
model_data$interpolation <- get_approxNA(x, model_data)
pred_data$interpolation <- get_approxNA(x, pred_data)
}else{
model_data$interpolation <- 0
pred_data$interpolation <- 0
}
# Remove any cells which are na in Elevation
# i.e. these lie outside the country
model_data <- model_data[complete.cases(model_data),]
pred_data <- pred_data[-which(pred_data$cell %in% which(is.na(Elev[]))),]
browser()
# Build model
rf_mod <- randomForest(data ~ interpolation + elev + x + y + layer,
data = model_data)
# Loop to inpute missing values
predictions <- predict(rf_mod, newdata = pred_data)
if(n_layers == 1){
x[pred_data$cell] <- as.vector(predictions)
}else{
for(i in 1:dim(x)[3]){
x[[i]][pred_data$cell[pred_data$layer == i]] <- as.vector(predictions[pred_data$layer == i])
}
}
return(x)
}
LST_gapfilled <- gapfill(LST, elevation, data_points = 40000)
# Build model
rf_mod <- randomForest(data ~ interpolation + elev + x + y + layer,
data = model_data)
model_data$data
model_data
pred_data
?view_palette
?get_colors_from_image
fire<-get_colors_from_image("https://raw.githubusercontent.com/HughSt/mappalettes/master/images/nathan-lindahl-1j18807_ul0-unsplash.jpg",5)
view_palette(fire, type="raster")
view_palette(fire, type="raster", n=10)
view_palette <- function(palette,
n = 5,
type = "bars"){
if(length(palette)>1){
palette <- name
}else{
palette <- map_palette(palette, n)
}
if(type=="bars"){
barplot(rep(1, n),
axes=F,
space=0,
border=NA,
col = palette)
}
if(type=="polys"){
data("swz_adm2")
pal <- leaflet::colorNumeric(palette, swz_adm2$elev)
plot(swz_adm2, col=pal(swz_adm2$elev))
}
if(type=="raster"){
data("swz_elev")
plot(swz_elev, col=palette, axes=F)
}
}
view_palette("bruiser", 6)
view_palette("bruiser", 9)
view_palette("bruiser", 9, type="poly")
view_palette("bruiser", 9, type="polys")
view_palette("bruiser", 9, type="raster")
view_palette(fire, 9, type="raster")
view_palette <- function(palette,
n = 5,
type = "bars"){
if(length(palette)>1){
palette <- palette
}else{
palette <- map_palette(palette, n)
}
if(type=="bars"){
barplot(rep(1, n),
axes=F,
space=0,
border=NA,
col = palette)
}
if(type=="polys"){
data("swz_adm2")
pal <- leaflet::colorNumeric(palette, swz_adm2$elev)
plot(swz_adm2, col=pal(swz_adm2$elev))
}
if(type=="raster"){
data("swz_elev")
plot(swz_elev, col=palette, axes=F)
}
}
view_palette(fire, 9, type="raster")
view_palette(fire, 9, type="polys")
view_palette(fire, type="polys")
fire
view_palette(c("#1D3141","#096168","#209478","#75C56E","#E2EE5E"),
type="raster")
colorQuantile
length(palette)
palette
length(fire)
view_palette <- function(palette,
n = 5,
type = "bars"){
if(length(palette)>1){
palette <- palette
}else{
palette <- map_palette(palette, n)
}
if(type=="bars"){
barplot(rep(1, n),
axes=F,
space=0,
border=NA,
col = palette)
}
if(type=="polys"){
data("swz_adm2")
#pal <- leaflet::colorNumeric(palette, swz_adm2$elev)
pal <- leaflet::colorQuantile(palette, swz_adm2$elev, n = length(palette))
plot(swz_adm2, col=pal(swz_adm2$elev))
}
if(type=="raster"){
data("swz_elev")
plot(swz_elev, col=palette, axes=F)
}
}
view_palette(c("#1D3141","#096168","#209478","#75C56E","#E2EE5E"),
type="raster")
view_palette(fire, type="polys")
get_colors_from_image("https://raw.githubusercontent.com/HughSt/mappalettes/master/images/nathan-lindahl-1j18807_ul0-unsplash.jpg",25)
fire<-get_colors_from_image("https://raw.githubusercontent.com/HughSt/mappalettes/master/images/nathan-lindahl-1j18807_ul0-unsplash.jpg",25)
view_palette(fiew,type="raster")
view_palette(fire,type="raster")
fire<-get_colors_from_image("https://raw.githubusercontent.com/HughSt/mappalettes/master/images/nathan-lindahl-1j18807_ul0-unsplash.jpg",25, order_by="chroma")
fire<-get_colors_from_image("https://raw.githubusercontent.com/HughSt/mappalettes/master/images/nathan-lindahl-1j18807_ul0-unsplash.jpg",25, order_by="hue")
view_palette(fire,type="raster")
fire<-get_colors_from_image("https://raw.githubusercontent.com/HughSt/mappalettes/master/images/nathan-lindahl-1j18807_ul0-unsplash.jpg",25, order_by="hue")
view_palette(fire,type="raster")
fire<-get_colors_from_image("https://raw.githubusercontent.com/HughSt/mappalettes/master/images/nathan-lindahl-1j18807_ul0-unsplash.jpg",25, order_by="hue")
fire<-get_colors_from_image("https://raw.githubusercontent.com/HughSt/mappalettes/master/images/nathan-lindahl-1j18807_ul0-unsplash.jpg",15, order_by="hue")
fire<-get_colors_from_image("https://raw.githubusercontent.com/HughSt/mappalettes/master/images/nathan-lindahl-1j18807_ul0-unsplash.jpg",15)
library(devtools)
install_github("disarm-platform/MapPalettes")
getwd()
setwd("~/Documents/Work/MEI/DiSARM/GitRepos/map_palettes")
document()
?view_palettes
?view_palette
install_github("disarm-platform/MapPalettes")
library(MapPalettes)
?view_palette
